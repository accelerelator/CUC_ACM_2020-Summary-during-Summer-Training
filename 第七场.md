# 数论分块

## 目录 <!-- omit in toc -->
- [数论分块](#数论分块)
  - [整数分块](#整数分块)
    - [另外的不会的东西](#另外的不会的东西)

## 整数分块

* **[2020牛客暑期多校训练营（第七场）]https://ac.nowcoder.com/acm/contest/5672/H**

> 题解：
> 这个题其实难点在于如何看出来是一个整数分块的板子，因为我个人认为若不是看了大家的题解很难把这个题和整数分块相联系，首先做这个题我觉得要很熟悉整数分块的知识，还有处理题目的技巧。

> 先看题目的条件，总结一下：
> 推出第一条结论：只有在满足n=1，n是k的倍数，或者n-1是k的倍数时，(n,k)是传奇元组。我们写出来是三种情况（1，k） （xk，k）  （xk+1，k）
> 那么我们从数据范围1e12入手，（1，k）是k种先不用管，先考虑 n=xk那么x=n/k，我们要求的ans就是要加上x这里的除是整除，我们枚举k，从2到k，每一个k对应的在N范围内的的n有x种（不会超时）然后带入（N-1）再算一遍就好了
> 注：要从2枚举因为从一的话会枚举重复这样的（1，k）元素。

> （代码没啥好说的感觉写注释也没啥用，都是板子）
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll; 
const int mod = 1e9+7;
ll ans =0;
ll n,k;
void solve(ll nn){
	for(ll l = 2, r; l <= nn && l<=k; l = r + 1){//注意区间端点是小于k的
	    r = min(nn / (nn / l) , k);
	    ans += (nn / l)%mod*((r - l + 1)%mod)%mod;
	    ans%=mod;
	}
}
int main(){
	cin>>n>>k;
	solve(n);
	solve(n-1);
	cout<<(ans+n+k-1)%mod;//减一是因为减去重复枚举的（1，1）
}
```
* [最后照例贴上参考的CSDN（里面有例题）]https://blog.csdn.net/weixin_43627118/article/details/104024380?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param

### 另外的不会的东西
* 积性函数
* 莫比乌斯反演
  

数论分块是莫比乌斯反演一个很重要的的前置知识（基本都要用到这个玩意）



**[2020牛客暑期多校训练营（第七场）]https://ac.nowcoder.com/acm/contest/5672/D**

题解：这题就离谱，我们开始拿python打表数 ，但是变得很大就会损失精度，然后就蹦出了很多很多的结果。。。。我们开始天真的以为除了1和24之外真的还有别的数，于是我们交了python，果然超时了，然后就是一直自闭，直到我们偶然想试试1和24，就ac了。。。。。。果然python也不靠谱。。。。。

**AC代码：**

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        long long n;
        scanf("%lld",&n);
        if(n == 1 || n == 24) printf("Fake news!\n");
        else {
            printf("Nobody knows it better than me!\n");
        }
    }
    return 0;
}
```
